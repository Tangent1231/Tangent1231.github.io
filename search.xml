<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>2021年秋季L4班题解</title>
    <url>/2022/01/07/2021%E5%B9%B4%E7%A7%8B%E5%AD%A3L4%E7%8F%AD%E9%A2%98%E8%A7%A3/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote>
<p>陪你们走过了夏天、秋天和冬天<br>春天即将到来<br>你们的步伐愈发坚定<br>老师可以欣慰地与你们说再见了</p>
</blockquote>
<span id="more"></span>

<h2 id="题目知识点和难度排序"><a href="#题目知识点和难度排序" class="headerlink" title="题目知识点和难度排序"></a>题目知识点和难度排序</h2><p>A. 汉诺双塔：递推，递归</p>
<p>B. 最大公约数和最小公倍数问题：递归</p>
<p>C. 放橘子：递归</p>
<p>D. 合影效果：排序</p>
<p>E. noip2007普及组 4.Hanoi双塔问题:高精度乘法，递推</p>
<p>F. 斜列求和：二维数据一般运用</p>
<p>老师认为的题目难度：</p>
<p>A &lt; D &lt; B &lt; F = E &lt; C</p>
<h2 id="题目讲解和AC代码"><a href="#题目讲解和AC代码" class="headerlink" title="题目讲解和AC代码"></a>题目讲解和AC代码</h2><h3 id="A-汉诺双塔：递推，递归"><a href="#A-汉诺双塔：递推，递归" class="headerlink" title="A. 汉诺双塔：递推，递归"></a>A. 汉诺双塔：递推，递归</h3><h4 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h4><p>题意：easy。就是两倍的2^n-1。</p>
<p>做法：怎么样做都行。</p>
<h4 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n;</span><br><span class="line">	<span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> ans = <span class="number">1</span>;</span><br><span class="line">	cin &gt;&gt; n;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		ans *= <span class="number">2</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; (ans<span class="number">-1</span>)*<span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="B-最大公约数和最小公倍数问题：递归"><a href="#B-最大公约数和最小公倍数问题：递归" class="headerlink" title="B.最大公约数和最小公倍数问题：递归"></a>B.最大公约数和最小公倍数问题：递归</h3><h4 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h4><p>题意：按题意来，题意比较清晰。枚举所有P、Q的可能性，统计个数。</p>
<p>做法：需要递归求一下最大公约数，然后带入式子判断是否满足条件。</p>
<h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> <span class="meta-keyword">warning</span>(disable:4996)；</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;<span class="comment">//求最大公约数</span></span><br><span class="line">	<span class="keyword">if</span> (a % b == <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> b;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">f</span>(b, a % b);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> x, y;</span><br><span class="line">	cin &gt;&gt; x &gt;&gt; y;</span><br><span class="line">	<span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i =<span class="number">1</span>; i * x &lt;= x * y; i++)<span class="comment">//遍历范围，并注意优化for循环</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (x * y % (i * x) == <span class="number">0</span> &amp;&amp; <span class="built_in">f</span>(i * x, x * y / (i * x)) == x) &#123;</span><br><span class="line">			ans++;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="C-放橘子：递归"><a href="#C-放橘子：递归" class="headerlink" title="C. 放橘子：递归"></a>C. 放橘子：递归</h3><h4 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a>题解</h4><p>题意：题意简单。</p>
<p>做法：</p>
<p>设dfs(m,n) 为m个橘子，n个盘子的放法数目，则先对n作讨论，<br>    当n&gt;m：必定有n-m个盘子永远空着，去掉它们对摆放橘子方法数目不产生影响。<br>    即if(n&gt;m) dfs(m,n) = dfs(m,m)。<br>    当n&lt;=m：不同的放法可以分成两类：<br>    1、一种是每个盘子都有一个橘子，那剩下的m-n个橘子放进盘子，结果是dfs(m-n,n)<br>    2、一种是至少一个盘子空着,注意这里是至少，递归下去，会搜索到n-2,n-3，结果是dfs(m,n-1).<br>    而总的放橘子的放法数目等于两者的和，即 dfs(m,n) =dfs(m,n-1)+dfs(m-n,n)<br>递归出口条件说明：<br>    当n=1时，所有橘子都必须放在一个盘子里，所以返回１；<br>    当没有橘子可放时，定义为１种放法；<br>    递归的两条路，第一条n会逐渐减少，终会到达出口n==1;<br>    第二条m会逐渐减少，因为n&gt;m时，我们会return dfs(m,m)，所以终会到达出口m==0。</p>
<h4 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> <span class="meta-keyword">warning</span>(disable:4996)；</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> t, n, m;</span><br><span class="line"><span class="keyword">int</span> k[<span class="number">10086</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (m == <span class="number">0</span> || m == <span class="number">1</span> || n == <span class="number">1</span>)<span class="comment">//橘子没了，或者橘子只有一个，或者盘子只要一个</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;<span class="comment">//返回结果为1</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (m &lt; n)<span class="comment">//如果橘子数量&lt;盘子数量，最多只能放m个盘子，结果必然是dfs(m,m);</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">dfs</span>(m, m);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (m &gt;= n)<span class="comment">//如果橘子的数量&gt;盘子数量，两种情况考虑：</span></span><br><span class="line">    <span class="comment">//1.一种是每个盘子都有一个橘子，那剩下的m-n个橘子放进盘子，结果是dfs(m-n,n)；</span></span><br><span class="line">    <span class="comment">//2.一种是至少一个盘子空着,注意这里是至少，递归下去，会搜索到n-2,n-3，结果是dfs(m,n-1)。</span></span><br><span class="line">    <span class="comment">//两个结果要进行累加</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">dfs</span>(m - n, n) + <span class="built_in">dfs</span>(m, n - <span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cin &gt;&gt; t;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= t; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		cin &gt;&gt; m &gt;&gt; n;</span><br><span class="line">		cout&lt;&lt;<span class="built_in">dfs</span>(m, n)&lt;&lt;endl;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="D-合影效果：排序"><a href="#D-合影效果：排序" class="headerlink" title="D. 合影效果：排序"></a>D. 合影效果：排序</h3><h4 id="题解-2"><a href="#题解-2" class="headerlink" title="题解"></a>题解</h4><p>题意：将男生和女生分开排序，男生从矮到高排，女生从高到矮排序。</p>
<p>做法：根据male和female存入两个不同的数组，然后可以用sort直接排。</p>
<h4 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="keyword">double</span> a, <span class="keyword">double</span> b)</span><span class="comment">//写一个排序的函数，从大到小</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> a &gt; b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n;</span><br><span class="line">	cin &gt;&gt; n;</span><br><span class="line">	<span class="keyword">int</span> pos1 = <span class="number">0</span>, pos2 = <span class="number">0</span>;<span class="comment">//男生和女生的数组大小</span></span><br><span class="line">	<span class="keyword">double</span> boy[<span class="number">50</span>], girl[<span class="number">50</span>];<span class="comment">//注意类型是用double类型存储</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		string sex;</span><br><span class="line">		<span class="keyword">double</span> height;</span><br><span class="line">		cin &gt;&gt; sex &gt;&gt; height;</span><br><span class="line">		<span class="keyword">if</span> (sex == <span class="string">&quot;male&quot;</span>)<span class="comment">//如果是男生，存进boy数组</span></span><br><span class="line">		&#123;</span><br><span class="line">			boy[pos1] = height;</span><br><span class="line">			pos1++;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span><span class="comment">//否则存入女生数组</span></span><br><span class="line">		&#123;</span><br><span class="line">			girl[pos2] = height;</span><br><span class="line">			pos2++;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">sort</span>(boy, boy + pos1);<span class="comment">//男生从高到矮排序</span></span><br><span class="line">	<span class="built_in">sort</span>(girl, girl + pos2, cmp);<span class="comment">//女生从矮到高排序</span></span><br><span class="line">	<span class="comment">//输出，保留两位小数</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; pos1; i++)</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%.2lf &quot;</span>, boy[i]);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; pos2; i++)</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%.2lf &quot;</span>, girl[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="E-noip2007普及组-4-Hanoi双塔问题"><a href="#E-noip2007普及组-4-Hanoi双塔问题" class="headerlink" title="E. noip2007普及组 4.Hanoi双塔问题"></a>E. noip2007普及组 4.Hanoi双塔问题</h3><h4 id="题解-3"><a href="#题解-3" class="headerlink" title="题解"></a>题解</h4><p>题意：A题升级版本。</p>
<p>做法：高精度乘法。</p>
<h4 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">100010</span>],n,top=<span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i,j;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">	a[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;=n; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span>(j=<span class="number">1</span>; j&lt;=<span class="number">200</span>; j++)</span><br><span class="line">		&#123;</span><br><span class="line">			a[j]=a[j]*<span class="number">2</span>+a[j<span class="number">-1</span>]/<span class="number">10</span>;</span><br><span class="line">			a[j<span class="number">-1</span>]=a[j<span class="number">-1</span>]%<span class="number">10</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	a[<span class="number">1</span>]=a[<span class="number">1</span>]<span class="number">-2</span>;</span><br><span class="line">	i=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span>(a[i]&lt;<span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		a[i]=a[i]+<span class="number">10</span>;</span><br><span class="line">		a[i+<span class="number">1</span>]--;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">200</span>; i&gt;<span class="number">0</span>; i--)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(a[i])</span><br><span class="line">		&#123;</span><br><span class="line">			top=i;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(i=top; i&gt;=<span class="number">1</span>; i--) <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,a[i]);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; </span><br><span class="line"> </span><br></pre></td></tr></table></figure>


<h3 id="F-斜列求和：二维数据一般运用"><a href="#F-斜列求和：二维数据一般运用" class="headerlink" title="F. 斜列求和：二维数据一般运用"></a>F. 斜列求和：二维数据一般运用</h3><h4 id="题解-4"><a href="#题解-4" class="headerlink" title="题解"></a>题解</h4><p>题意：这题根据样例解释可以看出，它的求和先从左下角开始的，<br>3=3</p>
<p>4=0+4</p>
<p>8=2+3+3</p>
<p>7=2+0+1+3</p>
<p>7=3+0+3</p>
<p>6=3+3</p>
<p>4=4<br>然后逐渐往上移动，去求斜列的和，是有些难度。</p>
<p>做法：两种做法：1.将二维数组拆分为两部分去处理，一部分是矩形的左下角部分，另一部分是右上角部分；2.将题目里的式子运用到数组里，稍微有些难理解。</p>
<h4 id="代码-4"><a href="#代码-4" class="headerlink" title="代码"></a>代码</h4><p>方法一：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> n,sum;</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">505</span>][<span class="number">505</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)<span class="comment">//存n*n的二维矩阵</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            cin&gt;&gt;a[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//这是左下角的部分</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">    	<span class="keyword">int</span> k=n,g=i;<span class="comment">//横纵坐标</span></span><br><span class="line">    	sum=<span class="number">0</span>;<span class="comment">//求和</span></span><br><span class="line">        <span class="keyword">while</span>(k&gt;<span class="number">0</span>&amp;&amp;g&gt;<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            sum=sum+a[k][g];</span><br><span class="line">            k--;</span><br><span class="line">            g--;</span><br><span class="line">        &#125;</span><br><span class="line">        cout&lt;&lt;sum&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//这是右上角的部分</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=n<span class="number">-1</span>;i&gt;=<span class="number">1</span>;i--)</span><br><span class="line">    &#123;</span><br><span class="line">    	<span class="keyword">int</span> k=i,g=n;<span class="comment">//横纵坐标</span></span><br><span class="line">    	sum=<span class="number">0</span>;<span class="comment">//求和</span></span><br><span class="line">        <span class="keyword">while</span>(k&gt;<span class="number">0</span>&amp;&amp;g&gt;<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            sum=sum+a[k][g];</span><br><span class="line">            k--;</span><br><span class="line">            g--;</span><br><span class="line">        &#125;</span><br><span class="line">        cout&lt;&lt;sum&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>方法二：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">1005</span>][<span class="number">1005</span>], ans[<span class="number">2005</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n - <span class="number">1</span>; i++)<span class="comment">//特殊的存矩阵方式，坐标位置按题目要来存</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = n - <span class="number">1</span>; j &gt;= <span class="number">0</span>; j--)</span><br><span class="line">			<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a[i][j]);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">2</span> * n - <span class="number">1</span>; i++)<span class="comment">//需要求的和的长度</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">0</span>; x &lt;= n - <span class="number">1</span>; x++)</span><br><span class="line">		&#123;</span><br><span class="line">			ans[i] = ans[i] + a[x][-x + i - <span class="number">1</span>];<span class="comment">//按斜率和x的公式求出对应的y，即可求和</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span> * n - <span class="number">1</span>; i &gt;= <span class="number">1</span>; i--) cout &lt;&lt; ans[i] &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>






<p>若有其他疑问，请在课程群内提问，若以后想和老师探讨一些问题，可以加入QQ群：875543997，仅做学习交流群使用。</p>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>技术</tag>
        <tag>Web</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>2021年秋季L3班题解</title>
    <url>/2022/01/07/2021%E5%B9%B4%E7%A7%8B%E5%AD%A3L3%E7%8F%AD%E9%A2%98%E8%A7%A3/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote>
<p>陪你们走过了夏天、秋天和冬天<br>春天即将到来<br>你们的步伐愈发坚定<br>老师可以欣慰地与你们说再见了</p>
</blockquote>
<span id="more"></span>

<h2 id="题目知识点和难度排序"><a href="#题目知识点和难度排序" class="headerlink" title="题目知识点和难度排序"></a>题目知识点和难度排序</h2><p>A. 最长平台：一维数组基本运用</p>
<p>B. 四面楚歌：高精度A+B，思维，规律</p>
<p>C. 通天之汉诺塔：高精度乘法，思维，规律</p>
<p>D. 斜列求和：二维数据一般运用</p>
<p>E. A * B问题：高精度 * 低精度</p>
<p>F. 合影效果：排序</p>
<p>G. 字符串输入输出：字符串输入输出</p>
<p>老师认为的题目难度：</p>
<p>G &lt; A &lt; F &lt; D = E = B &lt; C</p>
<h2 id="题目讲解和AC代码"><a href="#题目讲解和AC代码" class="headerlink" title="题目讲解和AC代码"></a>题目讲解和AC代码</h2><h3 id="A-最长平台：一维数组基本运用"><a href="#A-最长平台：一维数组基本运用" class="headerlink" title="A. 最长平台：一维数组基本运用"></a>A. 最长平台：一维数组基本运用</h3><h4 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h4><p>题意：这题就是要求你在数组中，找到一串最长的数字，这些数字都是相同的，输出这串数据的长度。</p>
<p>做法：读入后，用maxx存储最终答案，用cnt存储每一段相同数字长度，默认从第一位开始存储，然后遍历数组下标0~n-1，如果第i位数组元素和i+1位数组元素相同，cnt++，如果不同，说明要重新开始统计数组长度，比较一下最终答案和当前计数，计数器变成0。</p>
<h4 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> <span class="meta-keyword">warning</span>(disable:4996)；</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n;</span><br><span class="line">	<span class="keyword">int</span> a[<span class="number">1200</span>];</span><br><span class="line">	cin &gt;&gt; n;<span class="comment">//读入数组长度和数组元素</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		cin &gt;&gt; a[i];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> maxx = <span class="number">0</span>;<span class="comment">//最终答案</span></span><br><span class="line">	<span class="keyword">int</span> cnt = <span class="number">1</span>;<span class="comment">//计数器，统计每一段相同数字长度，从第一位开始统计</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n ; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (a[i] == a[i + <span class="number">1</span>])</span><br><span class="line">			cnt++;<span class="comment">//如果a[i]和a[i+1]相等，说明长度需要++</span></span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			maxx = <span class="built_in">max</span>(cnt, maxx);<span class="comment">//如果不等，说明统计该平台结束，比较一下最终答案和当前计数</span></span><br><span class="line">			cnt = <span class="number">1</span>;<span class="comment">//计数器归零</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; maxx;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="B-四面楚歌：高精度A-B，思维，规律"><a href="#B-四面楚歌：高精度A-B，思维，规律" class="headerlink" title="B. 四面楚歌：高精度A+B，思维，规律"></a>B. 四面楚歌：高精度A+B，思维，规律</h3><h4 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h4><p>题意：是一道找规律的题目，画图就会发现，最后答案是a+b+1。</p>
<p>做法：取用最传统的A+B代码，在进行进位前，给c[1]，也就是个位+1，然后其他是一模一样的。</p>
<h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> a[<span class="number">10005</span>] = &#123; <span class="number">0</span> &#125;, b[<span class="number">10005</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">	string s1, s2;</span><br><span class="line">	cin &gt;&gt; s1 &gt;&gt; s2;</span><br><span class="line">	<span class="keyword">int</span> len1 = s1.<span class="built_in">size</span>();</span><br><span class="line">	<span class="keyword">int</span> len2 = s2.<span class="built_in">size</span>();</span><br><span class="line">	<span class="keyword">int</span> len3 = <span class="built_in">max</span>(len1, len2) + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= len1; i++) &#123;</span><br><span class="line">		a[len1 - i] = s1[i] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= len2; i++) &#123;</span><br><span class="line">		b[len2 - i] = s2[i] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> c[<span class="number">10100</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= len3; i++) &#123;</span><br><span class="line">		c[i] = a[i] + b[i];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//结论为A+B+1，在个位上+1即可，然后做进位处理</span></span><br><span class="line">	c[<span class="number">1</span>] ++;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= len3; i++) &#123;</span><br><span class="line">		c[i + <span class="number">1</span>] += c[i] / <span class="number">10</span>;</span><br><span class="line">		c[i] %= <span class="number">10</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> k = len3;</span><br><span class="line">	<span class="keyword">while</span> (c[k] == <span class="number">0</span> &amp;&amp; k &gt; <span class="number">1</span>)k--;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = k; i &gt;= <span class="number">1</span>; i--) &#123;</span><br><span class="line">		cout &lt;&lt; c[i];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h3 id="C-通天之汉诺塔：高精度乘法，思维，规律"><a href="#C-通天之汉诺塔：高精度乘法，思维，规律" class="headerlink" title="C. 通天之汉诺塔：高精度乘法，思维，规律"></a>C. 通天之汉诺塔：高精度乘法，思维，规律</h3><h4 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a>题解</h4><p>题意：这题是询问汉诺塔移动次数，可能对低年级同学来说找规律比较难，最终规律是2^n-1。</p>
<p>做法：先处理一下2^n次，这题和之前的组合是类似的。只要最后再处理一下-1的问题即可。</p>
<h4 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> n;</span><br><span class="line">	cin &gt;&gt; n;</span><br><span class="line">	<span class="comment">//结果</span></span><br><span class="line">	<span class="keyword">int</span> a[<span class="number">100005</span>] = &#123; <span class="number">0</span>,<span class="number">2</span> &#125;;</span><br><span class="line">	<span class="keyword">int</span> len = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= len; j++)</span><br><span class="line">		&#123;</span><br><span class="line">			a[j] *= <span class="number">2</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= len; j++)</span><br><span class="line">		&#123;</span><br><span class="line">			a[j + <span class="number">1</span>] += a[j] / <span class="number">10</span>;</span><br><span class="line">			a[j] = a[j] % <span class="number">10</span>;</span><br><span class="line">			<span class="keyword">if</span> (j == len &amp;&amp; a[j + <span class="number">1</span>] &gt; <span class="number">0</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				len++;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	a[<span class="number">1</span>]--;<span class="comment">//最后各位-1，不会出现各位为0的情况</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = len; i &gt;= <span class="number">1</span>; i--)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, a[i]);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="D-斜列求和：二维数据一般运用"><a href="#D-斜列求和：二维数据一般运用" class="headerlink" title="D. 斜列求和：二维数据一般运用"></a>D. 斜列求和：二维数据一般运用</h3><h4 id="题解-2"><a href="#题解-2" class="headerlink" title="题解"></a>题解</h4><p>题意：这题根据样例解释可以看出，它的求和先从左下角开始的，<br>3=3</p>
<p>4=0+4</p>
<p>8=2+3+3</p>
<p>7=2+0+1+3</p>
<p>7=3+0+3</p>
<p>6=3+3</p>
<p>4=4<br>然后逐渐往上移动，去求斜列的和，是有些难度。</p>
<p>做法：两种做法：1.将二维数组拆分为两部分去处理，一部分是矩形的左下角部分，另一部分是右上角部分；2.将题目里的式子运用到数组里，稍微有些难理解。</p>
<h4 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h4><p>方法一：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> n,sum;</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">505</span>][<span class="number">505</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)<span class="comment">//存n*n的二维矩阵</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            cin&gt;&gt;a[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//这是左下角的部分</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">    	<span class="keyword">int</span> k=n,g=i;<span class="comment">//横纵坐标</span></span><br><span class="line">    	sum=<span class="number">0</span>;<span class="comment">//求和</span></span><br><span class="line">        <span class="keyword">while</span>(k&gt;<span class="number">0</span>&amp;&amp;g&gt;<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            sum=sum+a[k][g];</span><br><span class="line">            k--;</span><br><span class="line">            g--;</span><br><span class="line">        &#125;</span><br><span class="line">        cout&lt;&lt;sum&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//这是右上角的部分</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=n<span class="number">-1</span>;i&gt;=<span class="number">1</span>;i--)</span><br><span class="line">    &#123;</span><br><span class="line">    	<span class="keyword">int</span> k=i,g=n;<span class="comment">//横纵坐标</span></span><br><span class="line">    	sum=<span class="number">0</span>;<span class="comment">//求和</span></span><br><span class="line">        <span class="keyword">while</span>(k&gt;<span class="number">0</span>&amp;&amp;g&gt;<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            sum=sum+a[k][g];</span><br><span class="line">            k--;</span><br><span class="line">            g--;</span><br><span class="line">        &#125;</span><br><span class="line">        cout&lt;&lt;sum&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>方法二：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">1005</span>][<span class="number">1005</span>], ans[<span class="number">2005</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n - <span class="number">1</span>; i++)<span class="comment">//特殊的存矩阵方式，坐标位置按题目要来存</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = n - <span class="number">1</span>; j &gt;= <span class="number">0</span>; j--)</span><br><span class="line">			<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a[i][j]);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">2</span> * n - <span class="number">1</span>; i++)<span class="comment">//需要求的和的长度</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">0</span>; x &lt;= n - <span class="number">1</span>; x++)</span><br><span class="line">		&#123;</span><br><span class="line">			ans[i] = ans[i] + a[x][-x + i - <span class="number">1</span>];<span class="comment">//按斜率和x的公式求出对应的y，即可求和</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span> * n - <span class="number">1</span>; i &gt;= <span class="number">1</span>; i--) cout &lt;&lt; ans[i] &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="E-A-B问题：高精度-低精度"><a href="#E-A-B问题：高精度-低精度" class="headerlink" title="E. A*B问题：高精度 * 低精度"></a>E. A*B问题：高精度 * 低精度</h3><h4 id="题解-3"><a href="#题解-3" class="headerlink" title="题解"></a>题解</h4><p>题意：就是大数*小数。</p>
<p>做法：就是一个字符串变成数组，然后用这个小数按位相乘，处理进位即可。</p>
<h4 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">2000</span>],  c[<span class="number">2001</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    string s1;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="comment">/*读入开始*/</span></span><br><span class="line">    cin &gt;&gt; s1 &gt;&gt;n;</span><br><span class="line">    <span class="keyword">int</span> len1 = s1.<span class="built_in">size</span>();</span><br><span class="line">    <span class="comment">/*结果位数最大：为s1和s2长度的最大值+1*/</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len1; i++)</span><br><span class="line">        a[len1 - i] = s1[i] - <span class="number">48</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> len3 = len1 + <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//按位相乘，结果存到位置上</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= len1; i++)</span><br><span class="line">    &#123;<span class="comment">//第一个for循环遍历a</span></span><br><span class="line">        c[i] = a[i] * n;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//处理进位</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= len3; i++) &#123;</span><br><span class="line">        c[i + <span class="number">1</span>] += c[i] / <span class="number">10</span>;</span><br><span class="line">        c[i] %= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//处理最高位是否有值</span></span><br><span class="line">    <span class="keyword">int</span> k = len3;</span><br><span class="line">    <span class="keyword">while</span> (c[k] == <span class="number">0</span> &amp;&amp; k &gt; <span class="number">1</span>) k--;</span><br><span class="line">    <span class="comment">//逆序输出</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = k; i &gt;= <span class="number">1</span>; i--) &#123;</span><br><span class="line">        cout &lt;&lt; c[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="F-合影效果：排序"><a href="#F-合影效果：排序" class="headerlink" title="F. 合影效果：排序"></a>F. 合影效果：排序</h3><h4 id="题解-4"><a href="#题解-4" class="headerlink" title="题解"></a>题解</h4><p>题意：将男生和女生分开排序，男生从矮到高排，女生从高到矮排序。</p>
<p>做法：根据male和female存入两个不同的数组，然后可以用sort直接排。</p>
<h4 id="代码-4"><a href="#代码-4" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="keyword">double</span> a, <span class="keyword">double</span> b)</span><span class="comment">//写一个排序的函数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> a &gt; b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n;</span><br><span class="line">	cin &gt;&gt; n;</span><br><span class="line">	<span class="keyword">int</span> pos1 = <span class="number">0</span>, pos2 = <span class="number">0</span>;<span class="comment">//男生和女生的数组大小</span></span><br><span class="line">	<span class="keyword">double</span> boy[<span class="number">50</span>], girl[<span class="number">50</span>];<span class="comment">//注意类型是用double类型存储</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		string sex;</span><br><span class="line">		<span class="keyword">double</span> height;</span><br><span class="line">		cin &gt;&gt; sex &gt;&gt; height;</span><br><span class="line">		<span class="keyword">if</span> (sex == <span class="string">&quot;male&quot;</span>)<span class="comment">//如果是男生，存进boy数组</span></span><br><span class="line">		&#123;</span><br><span class="line">			boy[pos1] = height;</span><br><span class="line">			pos1++;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span><span class="comment">//否则存入女生数组</span></span><br><span class="line">		&#123;</span><br><span class="line">			girl[pos2] = height;</span><br><span class="line">			pos2++;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">sort</span>(boy, boy + pos1);<span class="comment">//男生从高到矮排序</span></span><br><span class="line">	<span class="built_in">sort</span>(girl, girl + pos2, cmp);<span class="comment">//女生从矮到高排序</span></span><br><span class="line">	<span class="comment">//输出，保留两位小数</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; pos1; i++)</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%.2lf &quot;</span>, boy[i]);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; pos2; i++)</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%.2lf &quot;</span>, girl[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="G-字符串输入输出：字符串输入输出"><a href="#G-字符串输入输出：字符串输入输出" class="headerlink" title="G. 字符串输入输出：字符串输入输出"></a>G. 字符串输入输出：字符串输入输出</h3><h4 id="题解-5"><a href="#题解-5" class="headerlink" title="题解"></a>题解</h4><p>题意：如题所示。</p>
<p>做法：输入一个字符串，然后输出两遍字符串，中间加一个空格。</p>
<h4 id="代码-5"><a href="#代码-5" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	string s;</span><br><span class="line">	cin &gt;&gt; s;</span><br><span class="line">	cout &lt;&lt; s &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; s;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>若有其他疑问，请在课程群内提问，若以后想和老师探讨一些问题，可以加入QQ群：875543997，仅做学习交流群使用。</p>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>技术</tag>
        <tag>Web</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>读书笔记--《深入React技术栈》（二）</title>
    <url>/2021/12/12/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E3%80%8A%E6%B7%B1%E5%85%A5React%E6%8A%80%E6%9C%AF%E6%A0%88%E3%80%8B%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote>
<p>本文为读书笔记系列之一——《深入React技术栈》第一章下<br>之前在up主蜡笔与小勋那里了解到一些快速阅读的方法：<br>将文章中你觉得有用的文字或段落记录下来，然后写你的读书感受，这样才能更快更好地读好一本书，把一本厚厚的资料读薄。以后看看自己记录的笔记，很快就能回忆起其他的内容（联想记忆）。希望我坚持下来吧，ヾ(◍°∇°◍)ﾉﾞ</p>
</blockquote>
<span id="more"></span>

<h1 id="初入React世界"><a href="#初入React世界" class="headerlink" title="初入React世界"></a>初入React世界</h1><h2 id="1-3-React组件"><a href="#1-3-React组件" class="headerlink" title="1.3 React组件"></a>1.3 React组件</h2><h3 id="1-3-1-组件的演变"><a href="#1-3-1-组件的演变" class="headerlink" title="1.3.1 组件的演变"></a>1.3.1 组件的演变</h3><ol>
<li><p>在 MV* 架构出现之前，组件主要分为两种：</p>
<ul>
<li>狭义上的组件，又称为UI组件。组件主要围绕在交互动作上的抽象；</li>
<li>广义上的组件，及带有业务含义和数据的UI组件组成。这类组件不仅有交互动作，更重要的是有数据与界面之间的交互。</li>
</ul>
</li>
<li><p>对于UI组件来说，一定会有3个部分组件：结构、样式和交互行为，分别对应着 HTML 、 CSS 和 JavaScript  。</p>
</li>
<li><p>组件封装的基本思路就是面向对象思想。交互基本上以操作 DOM 为主，逻辑上是结构上哪里需要变，我们就操作哪里。此外，对于js的机构，我们得到了几项规范标准组件的信息：</p>
<ul>
<li>基本的封装性：可以通过实例化的方法来制造对象；</li>
<li>简单的生命周期呈现：最明显的两个方法 constructor 和destroy，代表了组件的挂载和卸载过程；</li>
<li>明确的数据流动：这里的数据指的是调用组件的参数。</li>
</ul>
</li>
<li><p>W3C标准委员会最近才将类似的思想制定成了规范，称为 Web Components 。这个规范是想统一Web段关于组建的定义。它通过定义 Custom Elements （自定义元素）的方式来统一组件。每个自定义元素可以定义自己对外提供的属性、方法，还有事件，内部可以像写一个页面一样，专注于实现功能来完成对组件的封装。</p>
</li>
<li><p>Web Components的4个组成部分：</p>
<ul>
<li>HTML Templates定义了之前模板的概念</li>
<li>Custom Elements 定义了组件的展现方式</li>
<li>Shadow DOM 定义了组件的作用域范围、可以囊括样式</li>
<li>HTML Imports 提出了新的引入方式</li>
</ul>
</li>
</ol>
<h3 id="1-3-2-React组件的构建"><a href="#1-3-2-React组件的构建" class="headerlink" title="1.3.2 React组件的构建"></a>1.3.2 React组件的构建</h3><ol>
<li><p>React的本质就是关心元素的构成，React组件即为组件元素。组件元素被描述成纯粹的JSON对象，意味着可以使用方法或是类来构建。</p>
</li>
<li><p>React组件基本上由3个部分组成——属性（ props ）、状态（ state ）以及生命周期方法：</p>
<ul>
<li>-&gt; state、props -&gt; 生命周期 -&gt; Render -&gt;</li>
<li>生命周期的setState -&gt; state、props</li>
</ul>
</li>
<li><p>React组件可以接收参数，也可能有自身状态。一单接受到的参数或自身状态有所改变，React组件就会执行相应的生命周期方法，最后渲染。整个过程完全符合传统组件所定义的组件职责。</p>
</li>
<li><p>React 与 Web Components：</p>
<ul>
<li>从React组件上看，它与 Web Components 传达的理念是一致的，但两者的实现方式不同：<ul>
<li>React 自定义元素是库自己创建的，与Web Components规范并不通用；</li>
<li>React 渲染过程包含了模板的概念，即1.2节所讲的JSX；</li>
<li>React 组件的实现均在方法与类中，因此可以做到相互隔离，但不包括样式；</li>
<li>React 引用方法遵循ES6 module标准。</li>
</ul>
</li>
</ul>
</li>
<li><p>React 组件的构建方法：</p>
<ul>
<li>React.createClass构建组件是React最传统、也是兼容性最好的方法：<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> Button = React.createClass(&#123;</span><br><span class="line">  <span class="function"><span class="title">getDefaultProps</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> &#123;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">  <span class="function"><span class="title">render</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> (</span><br><span class="line">          <span class="xml"><span class="tag">&lt;&gt;</span><span class="tag">&lt;/&gt;</span></span></span><br><span class="line">      );</span><br><span class="line">  &#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure></li>
<li>ES6 classes是通过ES6标准的类语法的方式来构建方法<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Button</span> <span class="keyword">extends</span> <span class="title">Component</span></span>&#123;</span><br><span class="line"> <span class="function"><span class="title">constructor</span>(<span class="params">props</span>)</span></span><br><span class="line"> &#123;</span><br><span class="line">     <span class="built_in">super</span>(props);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">static</span> defaultProps = &#123;</span><br><span class="line"></span><br><span class="line"> &#125;;</span><br><span class="line"> <span class="function"><span class="title">render</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">return</span> (</span><br><span class="line">         <span class="xml"><span class="tag">&lt;&gt;</span><span class="tag">&lt;/&gt;</span></span></span><br><span class="line">     );</span><br><span class="line"> &#125;</span><br><span class="line">  </span><br></pre></td></tr></table></figure></li>
<li>无状态函数（stateless function）,官方颇为推崇<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Button</span>(<span class="params">&#123;&#125;</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        <span class="xml"><span class="tag">&lt;&gt;</span><span class="tag">&lt;/&gt;</span></span></span><br><span class="line">    );</span><br><span class="line">&#125;</span><br><span class="line">  </span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ol>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>技术</tag>
        <tag>读书</tag>
        <tag>Web</tag>
      </tags>
  </entry>
  <entry>
    <title>读书笔记--《深入React技术栈》（一）</title>
    <url>/2021/11/11/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E3%80%8A%E6%B7%B1%E5%85%A5React%E6%8A%80%E6%9C%AF%E6%A0%88%E3%80%8B%EF%BC%88%E4%B8%80%EF%BC%89/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote>
<p>本文为读书笔记系列之一——《深入React技术栈》第一章上<br>之前在up主蜡笔与小勋那里了解到一些快速阅读的方法：<br>将文章中你觉得有用的文字或段落记录下来，然后写你的读书感受，这样才能更快更好地读好一本书，把一本厚厚的资料读薄。以后看看自己记录的笔记，很快就能回忆起其他的内容（联想记忆）。希望我坚持下来吧，ヾ(◍°∇°◍)ﾉﾞ</p>
</blockquote>
<span id="more"></span>

<h1 id="初入React世界"><a href="#初入React世界" class="headerlink" title="初入React世界"></a>初入React世界</h1><h2 id="1-1-React简介"><a href="#1-1-React简介" class="headerlink" title="1.1 React简介"></a>1.1 React简介</h2><ul>
<li><p>React是FaceBook在2013年开源在Github上的JavaScript库。</p>
</li>
<li><p>React把用户界面抽象成一个组件。</p>
</li>
<li><p>开发者通过组合这些组件，最终得到功能丰富、可交互的页面。</p>
</li>
<li><p>通过引入JSX语言，复用组件变得非常容易，同时也能保证组件结构清晰。</p>
</li>
<li><p>有了组件这层抽象，React把代码和真实渲染目标隔离开来，除了可以在浏览器端渲染到DOM来开发页面外，还能用于开发原生移动应用。</p>
</li>
</ul>
<h3 id="1-1-1-专注视图层"><a href="#1-1-1-专注视图层" class="headerlink" title="1.1.1 专注视图层"></a>1.1.1 专注视图层</h3><ul>
<li>React并不是完整的MVC/MVVM框架，它专注于提供清晰、简介的View层解决方案。</li>
<li>而又与模板引擎不同，React不仅专注于解决View层的问题，又是一个包括View和Controller的库。</li>
</ul>
<h3 id="1-1-2-Virtual-DOM"><a href="#1-1-2-Virtual-DOM" class="headerlink" title="1.1.2 Virtual DOM"></a>1.1.2 Virtual DOM</h3><ul>
<li><p>真实页面对应一个DOM树。在传统页面的开发模式中，每次需要更新页面时，都要手动操作DOM来进行更新。</p>
</li>
<li><p>DOM操作非常昂贵。在前端开发中，性能消耗最大的就是DOM操作，而且这部分代码会让整体项目的代码变得难以维护。</p>
</li>
<li><p>React把真实DOM树转换成JavaScript对象树，也就是Virtual DOM。</p>
</li>
<li><p>每次数据更新后，重新计算Virtual DOM，并和上一次生成的Virtual DOM做对比，对发生变化的部分进行批量更新。React也提供了直观的 <strong>shouldComponentUpdate</strong> 生命周期回调，来减少数据变化后不必要的Virtual DOM对比过程，以保证性能。</p>
</li>
<li><p>它最大的好处在于方便和其他平台集成，比如react-native是基于Virtual DOM渲染出原生控件，因为React组件可以映射为对应的原生控件。</p>
</li>
</ul>
<h3 id="1-1-3-函数式编程"><a href="#1-1-3-函数式编程" class="headerlink" title="1.1.3 函数式编程"></a>1.1.3 函数式编程</h3><ul>
<li><p>函数式编程，对应的是声明式编程。</p>
</li>
<li><p>声明式编程的本质是lambda演算。</p>
</li>
<li><p>React把过去不断重复构建UI的过程抽象成了组件，且在给定参数的情况下约定渲染对应的UI界面。</p>
</li>
<li><p>React能充分利用很多函数是方法去减少冗余代码。</p>
</li>
<li><p>函数式编程才是React的精髓。</p>
</li>
</ul>
<h2 id="1-2-JSX语法"><a href="#1-2-JSX语法" class="headerlink" title="1.2 JSX语法"></a>1.2 JSX语法</h2><h3 id="1-2-1-JSX的由来"><a href="#1-2-1-JSX的由来" class="headerlink" title="1.2.1 JSX的由来"></a>1.2.1 JSX的由来</h3><ul>
<li><p>React为方便View层组件化，承载了构建HTML结构化页面的职责。</p>
</li>
<li><p>与其他模板语言不同之处在于React是通过创建于更新虚拟元素来管理整个Virtual DOM的。</p>
</li>
<li><p>JSX意在通过加入增强语法，使得JavaScript变得更快、更安全、更简单。</p>
</li>
<li><p>虚拟元素可以理解为真是元素的对应，它的构建与更新是在内存中完成的，并不会真正渲染到DOM中去。</p>
</li>
<li><p>在React中创建的虚拟元素可以分为两类：</p>
<ul>
<li><p>DOM元素（DOM element）：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">class</span>=<span class="string">&quot;btn btn-blue&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">em</span>&gt;</span>Confirm<span class="tag">&lt;/<span class="name">em</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li><p>组件元素:</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> DeleteAccount = <span class="function">() =&gt;</span>(</span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>Are you sure?<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">DangerButton</span>&gt;</span>Confirm<span class="tag">&lt;/<span class="name">DangerButton</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">Button</span> <span class="attr">color</span>=<span class="string">&quot;blue&quot;</span>&gt;</span>Cancel<span class="tag">&lt;/<span class="name">Button</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">)</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>JSX在产品打包阶段都已经编译成纯JavaScript，不会带来任何副作用。</p>
</li>
<li><p>使用JSX写法的代码更易于阅读与开发。</p>
</li>
</ul>
<h3 id="1-2-2-JSX基本语法"><a href="#1-2-2-JSX基本语法" class="headerlink" title="1.2.2 JSX基本语法"></a>1.2.2 JSX基本语法</h3><ul>
<li><p>JSX的官方定义是类XML语法的ECMAScript拓展。</p>
</li>
<li><p>JSX基本语法基本被XML囊括了。</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> List = <span class="function">() =&gt;</span>(</span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">Title</span>&gt;</span>This is title<span class="tag">&lt;/<span class="name">Title</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">li</span>&gt;</span>list item<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">li</span>&gt;</span>list item<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">li</span>&gt;</span>list item<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">)</span><br></pre></td></tr></table></figure></li>
<li><p>需要注意几点：</p>
<ul>
<li>定义标签时，只允许被一个标签包裹。</li>
<li>标签一定要闭合。</li>
</ul>
</li>
<li><p>DOM元素和组件元素，在JSX对应规格是HTML标签字母是否为小写字母，其中小写首字母对应DOM元素，而组件元素自然对应大写字母。</p>
</li>
<li><p>注释</p>
</li>
<li><p>DOCTYPE</p>
</li>
<li><p>元素属性：在JSX中，不论是DOM元素还是组件元素，它们都有属性。不同的是，DOM元素的属性是保准规范属性，但有两个例外——class和for，因为在JavaScript中这两个单词都是关键词。因此我们这么转换：</p>
<ul>
<li>class属性改为className</li>
<li>for属性改为htmlFor</li>
</ul>
</li>
<li><p>而组件元素的属性是完全自定义的属性，也可以理解为实现组件所需要的参数。比如</p>
<p><code>const Header=(title,children)=&gt;(</code></p>
<p><code>&lt;h3 title=&#123;title&#125;&gt;&lt;h3&gt;</code></p>
<p><code>);</code> </p>
</li>
<li><p>我们给Header组件加了一个title属性，那么可以这么调用</p>
<p><code>&lt;Header title=&quot;hello world&quot;&gt;Hello World&lt;/Header&gt;</code></p>
</li>
<li><p>可以看到，Header和h3中两个title的不同之处，一个代表的是自定义标签的属性可以传递，一个标签自带的属性无法传递。</p>
</li>
<li><p>值得注意的是，在写自定义属性的时候，都有标准写法改为小驼峰写法。</p>
</li>
<li><p>Boolean属性：</p>
<ul>
<li>属性Boolean属性值会导致JSX认为bool值设为了true。</li>
<li>要传false时，必须使用属性表达式。比如disabled、required、checked和readOnly等。</li>
<li>例如，<code>&lt;Checkbox checked=&#123;true&#125; /&gt;</code>可以简写为<code>&lt;Checkbox checked /&gt;</code></li>
</ul>
</li>
<li><p>展开属性</p>
<ul>
<li><p>如果事先知道组件需要的全部属性，JSX可以这样来写：</p>
<p><code>const component = &lt;Component name=&#123;name&#125; value=&#123;value&#125; /&gt;</code></p>
</li>
<li><p>如果你不知道要设置哪些props，那么现在最好不要设置它：</p>
</li>
</ul>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> component = <span class="xml"><span class="tag">&lt;<span class="name">Component</span> /&gt;</span></span>;</span><br><span class="line">component.props.name=name;</span><br><span class="line">component.props.value=value;</span><br></pre></td></tr></table></figure>

<ul>
<li>上述这样是反模式，因为React不能帮你检查属性类型。</li>
<li>这里，可以使用ES6 rest/spread特性来提高效率：</li>
</ul>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> data=&#123;<span class="attr">name</span>:<span class="string">&#x27;foo&#x27;</span>,<span class="attr">value</span>:<span class="string">&#x27;bar&#x27;</span>&#125;;</span><br><span class="line"><span class="keyword">const</span> component = <span class="xml"><span class="tag">&lt;<span class="name">Component</span> <span class="attr">name</span>=<span class="string">&#123;data.name&#125;</span> <span class="attr">value</span>=<span class="string">&#123;data.value&#125;</span>&gt;</span></span></span><br></pre></td></tr></table></figure>

<p>可以写成</p>
</li>
</ul>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> data=&#123;<span class="attr">name</span>:<span class="string">&#x27;foo&#x27;</span>,<span class="attr">value</span>:<span class="string">&#x27;bar&#x27;</span>&#125;;</span><br><span class="line"><span class="keyword">const</span> component = <span class="xml"><span class="tag">&lt;<span class="name">Component</span> &#123;<span class="attr">...data</span>&#125;&gt;</span></span></span><br></pre></td></tr></table></figure>

<h2 id="更新于2021-11-11-16：43-一章实在太多了"><a href="#更新于2021-11-11-16：43-一章实在太多了" class="headerlink" title="更新于2021/11/11 16：43 一章实在太多了"></a>更新于2021/11/11 16：43 一章实在太多了</h2>]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>技术</tag>
        <tag>读书</tag>
        <tag>Web</tag>
      </tags>
  </entry>
  <entry>
    <title>读书笔记 -《HTTP5权威指南》（一）</title>
    <url>/2021/11/07/%E3%80%8AHTTP5%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97%E3%80%8B-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote>
<p>本文为读书笔记系列之一——《HTTP5权威指南》第一章<br>之前在up主蜡笔与小勋那里了解到一些快速阅读的方法：<br>将文章中你觉得有用的文字或段落记录下来，然后写你的读书感受，这样才能更快更好地读好一本书，把一本厚厚的资料读薄。以后看看自己记录的笔记，很快就能回忆起其他的内容（联想记忆）。希望我坚持下来吧，ヾ(◍°∇°◍)ﾉﾞ</p>
</blockquote>
<span id="more"></span>

<h1 id="本章节感想"><a href="#本章节感想" class="headerlink" title="本章节感想"></a>本章节感想</h1><p>本来想把感受放到最后，发现，这才是我读书最重要的东西，应该提到最前面呀。</p>
<p>阅读完本章以后，发现Web的诞生源于科技，不过市场一直推动着Web和技术前进。微软与网景的市场之战我觉得还是挺有趣的，因为原文也是简单描写，不过现代和历史都是会有重映的。</p>
<p>Web技术已经逐渐密不可分了，现在的Web技术也是百花齐放，比如一些新的流行框架的到来，提供了很多便于开发者的方法和规范。</p>
<p>喝水不忘挖井人，也许我们也应该慢慢去回味过去的World Wide Web的故事，和掌握一些最基本的知识点，这可能在繁华的开发环境下，读这本书的意义。</p>
<h1 id="HTML5背景知识"><a href="#HTML5背景知识" class="headerlink" title="HTML5背景知识"></a>HTML5背景知识</h1><h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><ul>
<li><p>HTML(Hypertext Markup Language，超文本标记语言)。</p>
</li>
<li><p>刚诞生HTML和万维网的时候，我们还不厌其烦地把“World Wide Web”（万维网）全写出来，远没有今天受人瞩目，不能只简称为“Web”。</p>
</li>
<li><p>技术世界已经分为Web诞生前和诞生后两个时代了。</p>
</li>
<li><p>在此过程中，HTML有过扩充，有过增强，有过扭曲，有过煎熬，见过争斗，见过官司，受过忽视，受过追捧，曾被变为雕虫小技，也曾被誉为未来之星。</p>
</li>
<li><p>本书讲述的是HTML5。这是HTML标准的最新版本，意在为这项重要技术带来秩序、条理和改进。曾经的青涩少年终于成熟了。</p>
</li>
</ul>
<h2 id="1-1-HTML的历史"><a href="#1-1-HTML的历史" class="headerlink" title="1.1 HTML的历史"></a>1.1 HTML的历史</h2><h3 id="1-1-1-JavaScript的出场"><a href="#1-1-1-JavaScript的出场" class="headerlink" title="1.1.1 JavaScript的出场"></a>1.1.1 JavaScript的出场</h3><ul>
<li><p>和Java程序设计语言基本没有什么关系。</p>
</li>
<li><p>出自一家名为网景的公司。</p>
</li>
<li><p>它的出现标志着内嵌在Web浏览器中的客户端脚本程序控制功能的发端。</p>
</li>
<li><p>HTML5规定假定可以使用JavaScript，而且要想使用HTML5中新增的一些最为引人注目的特性也需要用到JavaScript。</p>
</li>
</ul>
<h3 id="1-1-2-浏览器战争的结束"><a href="#1-1-2-浏览器战争的结束" class="headerlink" title="1.1.2 浏览器战争的结束"></a>1.1.2 浏览器战争的结束</h3><ul>
<li><p>激烈的浏览器市场:微软用免费提供IE与网景收费的Navigator抢生意，这一招而后来被认定为反垄断法。</p>
</li>
<li><p>不过在坐着这个曾在那段时期为网景做过大约18个顾问的人看来，我从没见过像它那样一根筋地自残的公司。有些公司注定要成为别人的前车之鉴，网景就是其中之一。  </p>
</li>
<li><p>浏览器战争以网景倒台及微软受到惩处结束，为基于标准的网络浏览奠定了基础。HTML规范有了改进，遵从这个规范成了准则。</p>
</li>
</ul>
<h3 id="1-1-3-插件称雄"><a href="#1-1-3-插件称雄" class="headerlink" title="1.1.3 插件称雄"></a>1.1.3 插件称雄</h3><ul>
<li><p>插件是Web世界的“益虫”。它们可以提供一些单用HTML很难实现的高级特性和丰富内容。</p>
</li>
<li><p>浏览器开发商看插件不顺眼，因为它把控制权转移到了插件开发商手中。</p>
</li>
<li><p>HTML5的一大改进就是着力于让浏览器直接处理那些原本要使用Flash的富内容（rich content）。</p>
</li>
</ul>
<h3 id="1-1-4-语义HTML浮出水面"><a href="#1-1-4-语义HTML浮出水面" class="headerlink" title="1.1.4 语义HTML浮出水面"></a>1.1.4 语义HTML浮出水面</h3><ul>
<li>自HTML初次亮相以来，对内容进行自动处理日趋重要，人们也越来越致力于分开HTML元素的意义与内容再浏览器中的呈现方式。</li>
</ul>
<h3 id="1-1-5-发展态势：HTML标准滞后于其使用"><a href="#1-1-5-发展态势：HTML标准滞后于其使用" class="headerlink" title="1.1.5 发展态势：HTML标准滞后于其使用"></a>1.1.5 发展态势：HTML标准滞后于其使用</h3><ul>
<li><p>制定标准一般都是一个长期过程，像HTML这种应用官方的技术更是如此。参与方众多，每家都想把新标准往符合自己利益或观点的方向引。</p>
</li>
<li><p>负责制定HTML标准的是W3C（World Wide Web Consortium，万维网联盟）。</p>
</li>
<li><p>一条提案要花不少时间才能成为标准。而对HTML核心规范的修改则需经过很长时间才能得到批准。</p>
</li>
<li><p>HTML规范反应的知识几年前关于Web内容的前沿思考。这削弱了HTML标准的重要性，因为真正的革新并非来自W3C，而是来自浏览器和插件。</p>
</li>
</ul>
<h2 id="1-2-HTML5简介"><a href="#1-2-HTML5简介" class="headerlink" title="1.2 HTML5简介"></a>1.2 HTML5简介</h2><ul>
<li>HTML5不仅仅是HTML规范的最新版本，它还是一系列用来制作现代富Web内容的相关技术的总称。</li>
<li>最重要的三项技术是HTML5核心规范、CSS（Cascading Style Sheets，层叠样式表）和JavaScript。<ul>
<li>HTML核心规范定义用仪表及内容的元素，并明确其含义。</li>
<li>CSS可用于控制表记过的内容呈现在用户前面的外貌。</li>
<li>JavaScript则可以用来操纵HTML文档的内容以及响应用户的操作，此外要想使用HTML新增元素的一些为编程目的设计的特性也需要用到JavaScript。</li>
</ul>
</li>
<li>用于网页的各种技术之间的关联已经变得如此紧密，以至于需要通晓这些技术才能制作Web内容。</li>
</ul>
<h3 id="1-2-1-新标准"><a href="#1-2-1-新标准" class="headerlink" title="1.2.1 新标准"></a>1.2.1 新标准</h3><p>最大的不足之处大概要算没有一条可用来评估HTML5达标情况的基准线。</p>
<h3 id="1-2-2-引入原生多媒体支持"><a href="#1-2-2-引入原生多媒体支持" class="headerlink" title="1.2.2 引入原生多媒体支持"></a>1.2.2 引入原生多媒体支持</h3><p>支持在浏览器中直接播放视频和音频文件。</p>
<h3 id="1-2-3-引入可编程内容"><a href="#1-2-3-引入可编程内容" class="headerlink" title="1.2.3 引入可编程内容"></a>1.2.3 引入可编程内容</h3><p>HTML最大的变化之一是添加了Canvas元素。之所以重要，要使用Canvas就必须用到JavaScript。编程从而成了HTML文档中第一层次的事情。</p>
<h3 id="1-2-4-引入语义Web"><a href="#1-2-4-引入语义Web" class="headerlink" title="1.2.4 引入语义Web"></a>1.2.4 引入语义Web</h3><p>HTML5引入了一些用来分开元素的含义和内容呈现方式的特性和规则。它标志着HTML在走向成熟的道路上又迈上了一个新台阶，反映出制作和使用HTML内容的方式的多样性。</p>
<h3 id="1-3-HTML现况"><a href="#1-3-HTML现况" class="headerlink" title="1.3 HTML现况"></a>1.3 HTML现况</h3><h3 id="1-3-1-浏览器对HTML5支持情况"><a href="#1-3-1-浏览器对HTML5支持情况" class="headerlink" title="1.3.1 浏览器对HTML5支持情况"></a>1.3.1 浏览器对HTML5支持情况</h3><ul>
<li><p>在把某个特性用到实际项目之前，应该先核查一下浏览器是否支持这个特性。</p>
<ul>
<li>使用Modernizr（<a href="https://modernizr.com/">https://modernizr.com/</a>）之类的JavaScript库检查特性是可行的。可以用编程的方式判断用户使用的浏览器是否支持关键的HTML特性，借此可以决定在文档中应该使用哪些特性。</li>
<li>When Can I Use?网站（<a href="http://caniuse.com/">http://caniuse.com</a>）提供了浏览器的支持情况和采用率方面的详细信息，并且勤于修订。</li>
</ul>
</li>
</ul>
<h3 id="1-3-2-网站对HTML5的支持情况"><a href="#1-3-2-网站对HTML5的支持情况" class="headerlink" title="1.3.2 网站对HTML5的支持情况"></a>1.3.2 网站对HTML5的支持情况</h3><h2 id="1-4-本书结构"><a href="#1-4-本书结构" class="headerlink" title="1.4 本书结构"></a>1.4 本书结构</h2><h2 id="1-5-HTML5更多信息"><a href="#1-5-HTML5更多信息" class="headerlink" title="1.5 HTML5更多信息"></a>1.5 HTML5更多信息</h2><h2 id="1-6-小结"><a href="#1-6-小结" class="headerlink" title="1.6 小结"></a>1.6 小结</h2>]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>技术</tag>
        <tag>读书</tag>
        <tag>Web</tag>
      </tags>
  </entry>
  <entry>
    <title>关于hexo+github部署博客网站后，网站打开404问题个人总结</title>
    <url>/2021/10/31/%E5%85%B3%E4%BA%8Ehexo-github%E9%83%A8%E7%BD%B2%E5%8D%9A%E5%AE%A2%E7%BD%91%E7%AB%99%E5%90%8E%EF%BC%8C%E7%BD%91%E7%AB%99%E6%89%93%E5%BC%80404%E9%97%AE%E9%A2%98%E4%B8%AA%E4%BA%BA%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>很多人都遇到了相同的问题，为什么hexo本地预览没有问题，但是push到github上，打开显示404呢？本文会引用相关解决方案博客和讲述本人遇到的情况和解决方案。</p>
<span id="more"></span>

<h2 id="可供参考的博客"><a href="#可供参考的博客" class="headerlink" title="可供参考的博客"></a>可供参考的博客</h2><ul>
<li><a href="https://www.jianshu.com/p/2349c763cc02">HEXO更新博客后出现404</a></li>
<li><a href="https://blog.51cto.com/u_15344989/3654135">【亲测解决】hexo搭建Github博客上传后，访问网页显示404问题解决方案</a></li>
</ul>
<h2 id="本人遇到的情况"><a href="#本人遇到的情况" class="headerlink" title="本人遇到的情况"></a>本人遇到的情况</h2><p>很多博主都说了如何在github上建立一个repositories，然后名称一定要是’用户名+github.oi’，然后我开始怀疑自己用户名的大小写会不会影响用户名匹配（实际好像不会，看到了许多博主也是大小写用户名）。</p>
<p>比较关键的一点，很多文章中没有阐述，<strong>这个项目需要设置为public</strong>。</p>
<p>若一开始您和我一样设置为private的同学，将项目转为public的操作方法如下：</p>
<ul>
<li><p>可以打开项目，点击<strong>Settings</strong></p>
</li>
<li><p>点击Options</p>
</li>
<li><p>下拉到底</p>
</li>
<li><p>查看到Danger Zone中的Change repository visibility</p>
</li>
<li><p><strong>点击Change visibility</strong>。</p>
</li>
<li><p><strong>从项目private变为public</strong>。</p>
</li>
</ul>
<p>当你的项目为public的时候，你就可以访问Settings中Pages（private需要付费）。</p>
<p>Source里需要您选择部署的分支，请选择master，folder为/(root)即可。</p>
<p>如果部署成功，Pages会显示您现在的网站访问的地址。</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>博客</tag>
        <tag>技术</tag>
        <tag>网站</tag>
      </tags>
  </entry>
  <entry>
    <title>关于建成独立博客的一天</title>
    <url>/2021/10/31/hello-world/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>一直想拥有一个属于自己的博客网站，在11月开始前的一天动工。记录一下今天的学习过程</p>
<h2 id="访问的相关教程"><a href="#访问的相关教程" class="headerlink" title="访问的相关教程"></a>访问的相关教程</h2><ul>
<li><p><a href="http://blog.haoji.me/build-blog-website-by-hexo-github.html?from=xa#ce-shi-shi-fu-cheng-gong">搭建博客的网站</a></p>
</li>
<li><p><a href="https://shen-yu.gitee.io/">hexo主题</a></p>
</li>
<li><p><a href="https://sm.ms/">所用的图床</a></p>
</li>
<li><p><a href="https://cloud.tencent.com/">域名购买</a></p>
</li>
</ul>
<span id="more"></span>

<h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo new <span class="string">&quot;postName&quot;</span> <span class="comment">#新建文章</span></span><br><span class="line">hexo new page <span class="string">&quot;pageName&quot;</span> <span class="comment">#新建页面</span></span><br><span class="line">hexo generate <span class="comment">#生成静态页面至public目录</span></span><br><span class="line">hexo server <span class="comment">#开启预览访问端口（默认端口4000，&#x27;ctrl + c&#x27;关闭server）</span></span><br><span class="line">hexo deploy <span class="comment">#部署到GitHub</span></span><br><span class="line">hexo <span class="built_in">help</span>  <span class="comment"># 查看帮助</span></span><br><span class="line">hexo version  <span class="comment">#查看Hexo的版本</span></span><br><span class="line"></span><br><span class="line">hexo n == hexo new</span><br><span class="line">hexo g == hexo generate</span><br><span class="line">hexo s == hexo server</span><br><span class="line">hexo d == hexo deploy</span><br><span class="line"></span><br><span class="line">建议每次生成站点或部署之前都用 hexo clean 命令清理一下缓存，请使用 Ctrl + F5 清除缓存并刷新页面。</span><br><span class="line"></span><br><span class="line">hexo s -g --debug 热更新</span><br><span class="line">hexo s -g <span class="comment">#生成并本地预览</span></span><br><span class="line">hexo d -g <span class="comment">#生成并上传</span></span><br><span class="line"></span><br><span class="line">hexo new <span class="string">&#x27;my-first-blog&#x27;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="文章发表格式"><a href="#文章发表格式" class="headerlink" title="文章发表格式"></a>文章发表格式</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">---</span><br><span class="line">title: postName <span class="comment">#文章页面上的显示名称，一般是中文</span></span><br><span class="line">date: 2013-12-02 15:30:16 <span class="comment">#文章生成时间，一般不改，当然也可以任意修改</span></span><br><span class="line">categories: 默认分类 <span class="comment">#分类</span></span><br><span class="line">tags: [tag1,tag2,tag3] <span class="comment">#文章标签，可空，多标签请用格式，注意:后面有个空格</span></span><br><span class="line">description: 附加一段文章摘要，字数最好在140字以内，会出现在meta的description里面</span><br><span class="line">---</span><br><span class="line"></span><br><span class="line">以下是正文</span><br><span class="line"></span><br><span class="line"><span class="comment"># 前言</span></span><br><span class="line"></span><br><span class="line">使用github pages服务搭建博客的好处有：</span><br><span class="line"></span><br><span class="line">1. 全是静态文件，访问速度快；</span><br><span class="line">2. 免费方便，不用花一分钱就可以搭建一个自由的个人博客，不需要服务器不需要后台；</span><br><span class="line">3. 可以随意绑定自己的域名，不仔细看的话根本看不出来你的网站是基于github的；</span><br><span class="line"></span><br><span class="line">&lt;!--more--&gt;</span><br><span class="line"></span><br><span class="line">4. 数据绝对安全，基于github的版本管理，想恢复到哪个历史版本都行；</span><br><span class="line">5. 博客内容可以轻松打包、转移、发布到其它平台；</span><br><span class="line">6. 等等；</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>博客</tag>
        <tag>技术</tag>
        <tag>网站</tag>
      </tags>
  </entry>
</search>
